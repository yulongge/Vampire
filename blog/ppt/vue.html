<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Vue</title>
		<style>
			body {
	font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
h1, h2, h3 {
	font-weight: 400;
	margin-bottom: 0;
}
.remark-slide-content h1 { font-size: 3em; }
.remark-slide-content h2 { font-size: 2em; }
.remark-slide-content h3 { font-size: 1.6em; }
.footnote {
	position: absolute;
	bottom: 3em;
}
li p { line-height: 1.25em; }
.red { color: #fa0000; }
.large { font-size: 2em; }
a, a > code {
	color: rgb(249, 38, 114);
	text-decoration: none;
}
code {
	background: none repeat scroll 0 0 #F8F8FF;
  border: 1px solid #DEDEDE;
  border-radius: 3px 	;
  padding: 0 0.2em;
}
.remark-code, .remark-inline-code { font-family: "Bitstream Vera Sans Mono", "Courier", monospace; }
.remark-code-line-highlighted     { background-color: #373832; }
.pull-left {
	float: left;
	width: 47%;
}
.pull-right {
	float: right;
	width: 47%;
}
.pull-right ~ p {
	clear: both;
}
#slideshow .slide .content code {
	font-size: 0.8em;
}
#slideshow .slide .content pre code {
	font-size: 0.9em;
	padding: 15px;
}
.main-title, .title {
	background: #272822;
	color: #777872;
	text-shadow: 0 0 20px #333;
}
.title h1, .title h2, .main-title h1, .main-title h2 {
	color: #f3f3f3;
	line-height: 0.8em;
}
/* Custom */
.remark-code {
	display: block;
	padding: 0.5em;
}

		</style>
	</head>
	<body>
		<textarea id="source">
# Vue
---

## 简介

Vue(/vju:/, 类似于View)，一套构建用户界面的渐进式框架。采用`自底向上增量开发`的设计。它只关注视图层，容易上手，便于与第三方库整合。

> 与单文件组件和Vue生态系统支持的库结合使用时，Vue也完全能够为复杂的单页应用程序提供有力驱动

---

## 安装

Vue.js不支持IE8及其以下版本，因为Vue.js使用的ECMAScript5的特性在IE8下无法模拟。Vue支持所有兼容ECMAScript的浏览器。

http://caniuse.com/#feat=es5

- 直接引入`<script>`标签
	
> Vue会被注册一个全局变量。在开发环境中引入开发环境版本，包含完整的警告和调试模式，对开发更加友好!
> CDN
> - [unpkg](https://unpkg.com/vue) : npm 发布后立即同步
> - [jsDelivr](https://cdn.jsdelivr.net/npm/vue/dist/vue.js) : npm发布后需要一段时间才能同步，所以可能无法获取最新版本 
> - [cdnjs](https://cdnjs.cloudflare.com/ajax/libs/vue/2.4.0/vue.js) : 同jsDelivr

- Bower
	
```shell
bower install vue
```

- NPM

> 在用Vue构建大型应用程序时，推荐使用NPM安装方式，可以很好地与模块打包器(webpack/browserify)配合使用。

```shell
npm install vue
```

---


在NPM包的dist/目录下，你会找到许多不同的构建版本的Vue.js.

||UMD|CommonJS|ES Module|
|----|----|----|---|
|完整版本(Full)|vue.js|vue.common.js|vue.esm.js|
|只含有运行时版本(Runtime-only)|vue.runtime.js|vue.runtime.common.js|vue.runtime.esm.js|
|完整版本(生产环境)|vue.min.js|||
|只含有运行时版本(生产环境)|vue.runtime.min.js|||

---

> - 完整版本(Full)：包含编译器(compiler)和运行时(runtime)的构建版本。
> - 编译器(Compiler)：负责将模板字符串编译成 JavaScript 渲染函数(render function)的代码。
> - 运行时(Runtime)：负责创建 Vue 实例(creating Vue instances)、渲染(rendering)和修补虚拟 DOM(patching virtual DOM) 等的代码。基本上，等同于完整版本减去编译器。
> - UMD：UMD 构建版本能够直接在浏览器中通过 `<script>` 标签使用。Unpkg CDN 提供的默认文件 https://unpkg.com/vue，是运行时+编译器(Runtime + Compiler)的 UMD 构建版本。
> - CommonJS：CommonJS 版本用于较早期的打包器(bundler)（例如 browserify 或 webpack 1 等）中。用于这些打包器的默认文件(pkg.main)，是只含有运行时(Runtime only)的 CommonJS 构建版本(vue.runtime.common.js)
> - ES Module：ES 模块版本构建用于现代打包器（例如 webpack 2 或 rollup 等）中。用于这些打包器的默认文件(pkg.module)，是只含有运行时(Runtime only)的 ES Module 构建版本(vue.runtime.esm.js)。

---

### 命令行接口工具

Vue.js 提供了一个命令行接口工具，用于快速搭建大型单页面应用程序。能够为现代前端开发工程师流程，带来持久强力的基础框架，只需要几分钟，就可以建立并运行一个带有: 热重载，保存时代码检查以及可直接用于生产环境的构建配置的项目.

```shell
# 安装 vue-cli
npm install --global vue-cli
# 使用 "webpack" 模板创建一个新项目
vue init webpack my-project
# 安装依赖，然后开始！
cd my-project
npm install
npm run dev
```

> 对于初学者来说，不建议使用cli工具，影响我们学习，对于老手来说，也许我们也不屑于使用这个，当然我们都是很有自信的。

---

## 语法


> Vue实例的创建，语法，事件处理

---

### Vue实例

> 每个Vue应用都是通过Vue函数创建一个新的Vue实例开始的.

```js
var vm = new Vue({
	//选项
})
```

```html
<div id="app">
  {{ message }}
</div>

```

```js
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```

这样就创建了一个实例，创建时你可以传入一个选项对象。

---

#### 实例的生命的周期

![vue-lifecycle](https://yulongge.github.io/images/vue/vue_lifecycle.png)

---

如果熟悉react的话可以对比一下:

![react-lifecycle](https://yulongge.github.io/ppt/img/react.png)

---

### 模板语法

Vue使用基于HTML的模板语法，允许开发者声明式的将DOM绑定至底层Vue实例的数据。所有的Vue.js的模板都是合法的HTML,所以能被遵循规范的浏览器和HTML解析器解析。

在底层，Vue将模板编译成虚拟的DOM渲染函数，结合响应系统，在应用状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应用到DOM操作上。

当然你也可以不用模板，直接写渲染(render)函数，使用可选的JSX语法。

---

#### 文本

数据绑定使用了`Mustache`语法(双大括号)

```html
<span>Message: {{ msg }}</span>
```
> Mastache 会将数据解释为不同的文本，而非HTML代码，有时候我们想输出正真的HTML,需要使用`v-html`指令

---

#### 原始HTML

```html
<div v-html="rawHtml"></div>
```

这个div的内容将会被替换称为属性值rawHtml，直接作为HTML一一会忽略属性值中数据的绑定。

> 渲染任何html是很危险的，很容易导致xss攻击

---

#### 特性

Mustache 语法不能作用在HTML特性上，这时候应该使用v-bind指令

```html
<div v-bind:id="dynamicId"></div>
<div v-bind:disabled="isButtonDisabled">Button</div>
```

> 适用于布尔类型，如果求值结果是`falsy`(falsy不是false)的值，属性将会被删除

---

#### 使用JavaScript表达式

对于所有的数据绑定，Vue都提供了完全的JavaScript表达式支持

```js
{{ number + 1 }}
{{ ok ? 'yes' : 'no' }}
{{ message.split('').rerverse().join('')}}
```

```html
<div v-bind:id="'list-' + id"></div>
```

> 这些表达式会在所属的Vue实例的数据作用域下作为JavaScript被解析，有个限制就是，每个绑定都只能包含`单个表达式`.

```js
{{ var a = 1 }}
{{ if(ok) { return message } }}
//语句和流控制，都不会生效
```

---

### 指令

指令(Directives)是带有`v-`前缀的特殊属性，属性值预期是个`单个JavaScript表达式`(`v-for`例外)，职责是，当表达式的值改变时，将其产生连带影响，响应式的作用于DOM.

- v-on
- v-bind
- v-once
- v-for
- v-if
- v-else
- v-else-if
- v-show
- v-model
- v-html

---

#### 参数

一些指令能够接收一个`参数`, 在指令名称之后以冒号表示.

```html
// href是参数，v-bind将该元素的href属性与表达式url的值绑定.
<a v-bind: href="url">...</a>

//监听事件
<a v-on:click="doSomething">...</a>
```

---

#### 修饰符

修饰符(Modifiers)是以半角句号`.`指明的特殊后缀，用于指出一个指令该以特殊方式绑定。

```html
//.prevent 修饰符告诉v-on指令对于触发的事件调用`event.preventDefault();`
<form v-on:submit.prevent="onSubmit">...</form>
```

---

#### 自定义指令

```js
//注册全局的
Vue.directive('focus', {
	inserted: function(el) {
		el.focus()
	}
})

//注册局部的
new Vue({
	directive: {
		focus: {
			inserted: function(el) {
				el.focus()
			}
		}
	}
})


//调用
//<input v-focus>
```
---

#### 指令的钩子函数

- bind
- inserted
- update
- componentUpdated
- unbind

---

#### 钩子函数参数

- el
- binding
	+ name
	+ value
	+ oldValue
	+ expression
	+ arg
	+ modifiers

- vnode
- oldVnode
	
> 除了el之外，其他的参数都应该是只读的，尽量不要修改他们。

---

#### 简写

> 大多数情况下，我们可能想在bind 和 update 钩子上做重复动作，并且不想关心其他的钩子函数。

```js
Vue.derective('color-swatch', function(el, binding) {
	el.style.backgroundColor = binding.value
})
```

---

### Class && Style

> 操作元素的class列表和内联样式是数据绑定的一个常见需求，因为他们都是属性，所以可用`v-bind`处理它们,Vue为了防止字符串拼接带来的麻烦和易错，将v-bind用于class 和 style 时，做了增强，表达式结果的类型除了字符串之外，还可以是对象或数组。

- v-bind:class
- v-bind:style

---

### 条件语句

- v-if
- v-else-if
- v-else
- v-show

```html
<h1 v-if="ok">Yes</h1>
<h2 v-else-if="no">No</h2>
<h3 v-else>Don't known</h3>
```

---

> 因为是指令，所以只能添加到元素上，所以如果想切换多个元素，可以把一个`<template>`元素当做一个不可见的包裹元素，并在上面使用`v-if`.最终渲染结果将不包含`<template>`元素.

```html
<template v-if="ok">
	<h1>....</h1>
	<h1>....</h1>
	<h1>....</h1>
</template>
```

用`key`管理可复用的元素

> Vue会尽可能高效地渲染元素，通常会复用已有的元素而不是从头开始渲染。这么做Vue变得非常快。

```html
<template v-if="loginType === 'username'">
	<label>Username</label>
	<input placeholder="Enter your username">
</template>
<template v-else>
	<label>Email</label>
	<input placeholder="Enter your email">
</template>

```

---

代码切换loginType将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，`input`不会被替换掉，仅仅替换了它的placeholder.

但是这样也不总是符合实际需求的，所以Vue为你提供了一种方式来表达`这俩元素是完全独立的，不要复用它们的`.只需添加一个具有唯一值的`key`属性即可:

```html
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
```

---

`v-show`

> 简单的切换元素css属性display

```html
<h1 v-show="ok">Hello! </h1>
```

> v-shwo 不支持`<template>` ，也不支持`v-else`

---

`v-if` vs `v-show`

`v-if` 是真正的条件渲染，因为他会确保在切换过程中条件块内的事件监听和子组件适当的被销毁和重建。

> `v-if` 也是惰性的，如果在初始渲染时条件为假，则什么也不做，一直到条件第一次变为真时，才会开始渲染条件块。

`v-show`就简单的多，不管初始条件是什么，元素总是会被渲染的，并且只是简单地基于css进行切换。

> 一般来说，`v-if`有更高的切换开销，而`v-show`有更高的初始渲染开销。因此，如果需要频繁的切换，则使用`v-show`，如果在运行时条件很少改变，则使用`v-if`较好.

---

### 循环语句

`v-for`指令根据一组数组的选项列表进行渲染。`v-for`指令需要使用`item in items`形式的特殊语法， `items`是源数据数组并且`item`是数组元素迭代的别名。

```html
<ul id="example-1">
  <li v-for="item in items">
    {{ item.message }}
  </li>
</ul>

<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>

<div v-for="item of items"></div>
```

> `v-for` 还支持一个可选的第二个参数为当前项的索引，也可以ongoing`of` 代替 `in`作为分隔符，因为它是最近JavaScript迭代器的语法。

```js
var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

---

`v-for`还可以用来迭代对象的属性

```html
<ul id="v-for-object" class="demo">
  <li v-for="value in object">
    {{ value }}
  </li>
</ul>

<div v-for="(value, key) in object">
  {{ key }}: {{ value }}
</div>

<div v-for="(value, key, index) in object">
  {{ index }}. {{ key }}: {{ value }}
</div>
```

---

> 也可以用第二个参数为键名, 第三个参数为索引

```js
new Vue({
  el: '#v-for-object',
  data: {
    object: {
      firstName: 'John',
      lastName: 'Doe',
      age: 30
    }
  }
})
```

> 遍历对象时，是按Object.keys()的结果遍历的。

---

`key`

Vue用`v-for`渲染列表是，默认用`就地复用`策略。这种模式是高效的，但是只适用于不依赖子组件状态或临时DOM状态的渲染，为了追踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一的key属性，理想的`key`值是有唯一的id，用`v-bind`来绑定`key`值。

```html
<div v-for="item in items" v-bind:key="item.id">....</div>
```

---

`数组更新检测`

- 变异方法
	> Vue包含一组观察数组的变异方法，所以它们也将会触发视图更新。
	
	+ push()
	+ pop()
	+ shift()
	+ unshift()
	+ splice()
	+ sort()
	+ reverse()
	
	```js
	//打开控制台
	example1.items.push({ message: 'longgege coming...'});

	//会引起列表重新渲染
	```

---

- 替换数组
	> 变异数组会改变原始数组，相比之下也有非变异方法。它们不会改变原始数组，总是返回一个新数组，可以用新数组替换旧数组。
	
	+ filter()
	+ concat()
	+ slice()

	```js
	example1.items = example1.items.filter(function (item) {
	  return item.message.match(/Foo/)
	})
	```

	> 幸运的是，Vue为了使得DOM元素得到最大范围的重用实现了一些机智得到，启发式的方法，所以这样替换也是非常高效的操作。
	
---

- 注意事项
	> 由于JavaScript的限制，Vue不能检测一下变动的数组;
	
	+ 利用索引设置一个项时
	+ 修改数组长度时
	
	```js
	//利用索引
	vm.items[indexOfItem] = newValue;
	//解决办法
	Vue.set(example .items, indexOfItem, newValue);
	example.items.splice(indexOfItem, 1, newValue)


	//修改长度
	vm.items.length = newLength;
	//解决办法
	example.items.splice(newLength)
	```
---

`对象更改检测`

> 由于JavaScript限制，Vue不能检测对象属性的添加和删除

```js
var vm = new Vue({
	data: {
		user: {
			name: 'longgege'
		}
	}
});

vm.user.name = 'fanjiejie'; //不是响应式的

Vue.set(vm.user, 'age', 18);
this.$set(this.user, 'age', 18)
```

有时候需要为已有对象赋予多个新属性，比如Object.assign()或者_.extend().

```js
Object.assign(this.user, {
	age: 18,
	email: 'gaiyulong@gmail.com'
}) //不响应式

this.user = Object.assign({}, this.user, {
	age: 18,
	email: 'gaiyulong@gmail.com'
})

```

---

### 监听事件

`v-on`指令监听DOM事件触发。

```html
<div id="example-1">
  <button v-on:>增加 1</button>
  <p>这个按钮被点击了 {{ counter }} 次。</p>
</div>

<div id="example-2">
  	<!-- `greet` 是在下面定义的方法名 -->
  	<button v-on:click="greet">Greet</button>

	<!-- 内联处理器的方法 -->
	<button v-on:click="say('hi')">Say hi</button> 
	<!-- 有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法 -->
	<button v-on:click="warn('Form cannot be submitted yet.', $event)">
	  Submit
	</button>
</div>
```

```js
var example1 = new Vue({
  el: '#example-1',
  data: {
    counter: 0
  },
  methods: {
 	greet: function(event) {
		//....	
	},
	say: function(message) {
		console.log(message, 'msg');
	},
	warn: function (message, event) {
		// 现在我们可以访问原生事件对象
		if (event) event.preventDefault()
		alert(message)
	}
  }
})

example1.greet() // 也可以用JavaScript 直接调用
```

---

`事件修饰符`

在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。

Vue 为了解决这个问题，提供了`事件修饰符`,通过`(.)`表示的指令后缀来调用修饰符

- .stop
- .prevent
- .capture
- .self
- .once

```html
!-- 阻止单击事件冒泡 -->
<a v-on:click.stop="doThis"></a>
<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>
<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>
<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>
<!-- 添加事件侦听器时使用事件捕获模式 -->
<div v-on:click.capture="doThis">...</div>
<!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 -->
<div v-on:click.self="doThat">...</div>
<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a>
```


> 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。

---

`键值修饰符`

在监听键盘事件时，我们经常需要监测常见的键值。Vue 允许为 v-on 在监听键盘事件时添加关键修饰符

```html
<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
<input v-on:keyup.13="submit">
```
记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：

```html
<!-- 同上 -->
<input v-on:keyup.enter="submit">
<!-- 缩写语法 -->
<input @keyup.enter="submit">
```
---

全部的按键别名:

- .enter
- .tab
- .delete
- .esc
- .space
- .up
- .down
- .left
- .right
- .ctrl
- .alt
- .shift
- .meta

---


### 表单

Vue用v-model指令在表单控件元素上创建双向数据绑定

```html
<input v-model="message" placeholder="edit me">
<p>Message is: {{ message }}</p>
```

---

- 文本
- 多行文本
- 复选框
- 单选按钮
- 选择列表

---

修饰符

- .lazy
- .number
- .trim

>ii  

---

### 组件

组件(Component)是Vue最强大的功能之一。可以扩展HTML元素，封装可重用的代码。



		</textarea>
		<script src="https://gnab.github.io/remark/downloads/remark-latest.min.js"></script>
		<script>
			var slideshow = remark.create();
		</script>
		<script></script>
	</body>
</html>
